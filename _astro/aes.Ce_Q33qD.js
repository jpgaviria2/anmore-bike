/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function re(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function at(t,e=""){if(!Number.isSafeInteger(t)||t<0){const r=e&&`"${e}" `;throw new Error(`${r}expected integer >= 0, got ${t}`)}}function N(t,e,r=""){const n=re(t),o=t?.length,i=e!==void 0;if(!n||i&&o!==e){const s=r&&`"${r}" `,f=i?` of length ${e}`:"",c=n?`length=${o}`:`type=${typeof t}`;throw new Error(s+"expected Uint8Array"+f+", got "+c)}return t}function Ne(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash must wrapped by utils.createHasher");at(t.outputLen),at(t.blockLen)}function It(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function En(t,e){N(t,void 0,"digestInto() output");const r=e.outputLen;if(t.length<r)throw new Error('"digestInto() output" expected to be of length >='+r)}function _t(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function jt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function X(t,e){return t<<32-e|t>>>e}const $e=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",mn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Dt(t){if(N(t),$e)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=mn[t[r]];return e}const P={_0:48,_9:57,A:65,F:70,a:97,f:102};function be(t){if(t>=P._0&&t<=P._9)return t-P._0;if(t>=P.A&&t<=P.F)return t-(P.A-10);if(t>=P.a&&t<=P.f)return t-(P.a-10)}function Ut(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if($e)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let o=0,i=0;o<r;o++,i+=2){const s=be(t.charCodeAt(i)),f=be(t.charCodeAt(i+1));if(s===void 0||f===void 0){const c=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[o]=s*16+f}return n}function G(...t){let e=0;for(let n=0;n<t.length;n++){const o=t[n];N(o),e+=o.length}const r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){const i=t[n];r.set(i,o),o+=i.length}return r}function xn(t,e={}){const r=(o,i)=>t(i).update(o).digest(),n=t(void 0);return r.outputLen=n.outputLen,r.blockLen=n.blockLen,r.create=o=>t(o),Object.assign(r,e),Object.freeze(r)}function Ct(t=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof e?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(t))}const Bn=t=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,t])});function vn(t,e,r){return t&e^~t&r}function An(t,e,r){return t&e^t&r^e&r}class Rn{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(e,r,n,o){this.blockLen=e,this.outputLen=r,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(e),this.view=jt(this.buffer)}update(e){It(this),N(e);const{view:r,buffer:n,blockLen:o}=this,i=e.length;for(let s=0;s<i;){const f=Math.min(o-this.pos,i-s);if(f===o){const c=jt(e);for(;o<=i-s;s+=o)this.process(c,s);continue}n.set(e.subarray(s,s+f),this.pos),this.pos+=f,s+=f,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){It(this),En(e,this),this.finished=!0;const{buffer:r,view:n,blockLen:o,isLE:i}=this;let{pos:s}=this;r[s++]=128,_t(this.buffer.subarray(s)),this.padOffset>o-s&&(this.process(n,0),s=0);for(let a=s;a<o;a++)r[a]=0;n.setBigUint64(o-8,BigInt(this.length*8),i),this.process(n,0);const f=jt(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let a=0;a<u;a++)f.setUint32(4*a,d[a],i)}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}_cloneInto(e){e||=new this.constructor,e.set(...this.get());const{blockLen:r,buffer:n,length:o,finished:i,destroyed:s,pos:f}=this;return e.destroyed=s,e.finished=i,e.length=o,e.pos=f,o%r&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const tt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),On=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),et=new Uint32Array(64);class Sn extends Rn{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:r,C:n,D:o,E:i,F:s,G:f,H:c}=this;return[e,r,n,o,i,s,f,c]}set(e,r,n,o,i,s,f,c){this.A=e|0,this.B=r|0,this.C=n|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=f|0,this.H=c|0}process(e,r){for(let a=0;a<16;a++,r+=4)et[a]=e.getUint32(r,!1);for(let a=16;a<64;a++){const b=et[a-15],w=et[a-2],y=X(b,7)^X(b,18)^b>>>3,m=X(w,17)^X(w,19)^w>>>10;et[a]=m+et[a-7]+y+et[a-16]|0}let{A:n,B:o,C:i,D:s,E:f,F:c,G:u,H:d}=this;for(let a=0;a<64;a++){const b=X(f,6)^X(f,11)^X(f,25),w=d+b+vn(f,c,u)+On[a]+et[a]|0,m=(X(n,2)^X(n,13)^X(n,22))+An(n,o,i)|0;d=u,u=c,c=f,f=s+w|0,s=i,i=o,o=n,n=w+m|0}n=n+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,f=f+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,o,i,s,f,c,u,d)}roundClean(){_t(et)}destroy(){this.set(0,0,0,0,0,0,0,0),_t(this.buffer)}}class Ln extends Sn{A=tt[0]|0;B=tt[1]|0;C=tt[2]|0;D=tt[3]|0;E=tt[4]|0;F=tt[5]|0;G=tt[6]|0;H=tt[7]|0;constructor(){super(32)}}const Gt=xn(()=>new Ln,Bn(1));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oe=BigInt(0),Ft=BigInt(1);function Nt(t,e=""){if(typeof t!="boolean"){const r=e&&`"${e}" `;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function qe(t){if(typeof t=="bigint"){if(!St(t))throw new Error("positive bigint expected, got "+t)}else at(t);return t}function Rt(t){const e=qe(t).toString(16);return e.length&1?"0"+e:e}function He(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?oe:BigInt("0x"+t)}function Bt(t){return He(Dt(t))}function Te(t){return He(Dt(In(N(t)).reverse()))}function ie(t,e){at(e),t=qe(t);const r=Ut(t.toString(16).padStart(e*2,"0"));if(r.length!==e)throw new Error("number too large");return r}function Ze(t,e){return ie(t,e).reverse()}function In(t){return Uint8Array.from(t)}function _n(t){return Uint8Array.from(t,(e,r)=>{const n=e.charCodeAt(0);if(e.length!==1||n>127)throw new Error(`string contains non-ASCII character "${t[r]}" with code ${n} at position ${r}`);return n})}const St=t=>typeof t=="bigint"&&oe<=t;function Un(t,e,r){return St(t)&&St(e)&&St(r)&&e<=t&&t<r}function Nn(t,e,r,n){if(!Un(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function $n(t){let e;for(e=0;t>oe;t>>=Ft,e+=1);return e}const se=t=>(Ft<<BigInt(t))-Ft;function qn(t,e,r){if(at(t,"hashLen"),at(e,"qByteLen"),typeof r!="function")throw new Error("hmacFn must be a function");const n=E=>new Uint8Array(E),o=Uint8Array.of(),i=Uint8Array.of(0),s=Uint8Array.of(1),f=1e3;let c=n(t),u=n(t),d=0;const a=()=>{c.fill(1),u.fill(0),d=0},b=(...E)=>r(u,G(c,...E)),w=(E=o)=>{u=b(i,E),c=b(),E.length!==0&&(u=b(s,E),c=b())},y=()=>{if(d++>=f)throw new Error("drbg: tried max amount of iterations");let E=0;const B=[];for(;E<e;){c=b();const L=c.slice();B.push(L),E+=c.length}return G(...B)};return(E,B)=>{a(),w(E);let L;for(;!(L=B(y()));)w();return a(),L}}function ce(t,e={},r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function n(i,s,f){const c=t[i];if(f&&c===void 0)return;const u=typeof c;if(u!==s||c===null)throw new Error(`param "${i}" is invalid: expected ${s}, got ${u}`)}const o=(i,s)=>Object.entries(i).forEach(([f,c])=>n(f,c,s));o(e,!1),o(r,!0)}function pe(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(o!==void 0)return o;const i=t(r,...n);return e.set(r,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),k=BigInt(1),ft=BigInt(2),De=BigInt(3),Ce=BigInt(4),Ve=BigInt(5),Hn=BigInt(7),ke=BigInt(8),Tn=BigInt(9),je=BigInt(16);function Y(t,e){const r=t%e;return r>=j?r:e+r}function K(t,e,r){let n=t;for(;e-- >j;)n*=n,n%=r;return n}function Ee(t,e){if(t===j)throw new Error("invert: expected non-zero number");if(e<=j)throw new Error("invert: expected positive modulus, got "+e);let r=Y(t,e),n=e,o=j,i=k;for(;r!==j;){const f=n/r,c=n%r,u=o-i*f;n=r,r=c,o=i,i=u}if(n!==k)throw new Error("invert: does not exist");return Y(o,e)}function fe(t,e,r){if(!t.eql(t.sqr(e),r))throw new Error("Cannot find square root")}function Ke(t,e){const r=(t.ORDER+k)/Ce,n=t.pow(e,r);return fe(t,n,e),n}function Zn(t,e){const r=(t.ORDER-Ve)/ke,n=t.mul(e,ft),o=t.pow(n,r),i=t.mul(e,o),s=t.mul(t.mul(i,ft),o),f=t.mul(i,t.sub(s,t.ONE));return fe(t,f,e),f}function Dn(t){const e=Vt(t),r=Ye(t),n=r(e,e.neg(e.ONE)),o=r(e,n),i=r(e,e.neg(n)),s=(t+Hn)/je;return(f,c)=>{let u=f.pow(c,s),d=f.mul(u,n);const a=f.mul(u,o),b=f.mul(u,i),w=f.eql(f.sqr(d),c),y=f.eql(f.sqr(a),c);u=f.cmov(u,d,w),d=f.cmov(b,a,y);const m=f.eql(f.sqr(d),c),E=f.cmov(u,d,m);return fe(f,E,c),E}}function Ye(t){if(t<De)throw new Error("sqrt is not defined for small field");let e=t-k,r=0;for(;e%ft===j;)e/=ft,r++;let n=ft;const o=Vt(t);for(;me(o,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return Ke;let i=o.pow(n,e);const s=(e+k)/ft;return function(c,u){if(c.is0(u))return u;if(me(c,u)!==1)throw new Error("Cannot find square root");let d=r,a=c.mul(c.ONE,i),b=c.pow(u,e),w=c.pow(u,s);for(;!c.eql(b,c.ONE);){if(c.is0(b))return c.ZERO;let y=1,m=c.sqr(b);for(;!c.eql(m,c.ONE);)if(y++,m=c.sqr(m),y===d)throw new Error("Cannot find square root");const E=k<<BigInt(d-y-1),B=c.pow(a,E);d=y,a=c.sqr(B),b=c.mul(b,a),w=c.mul(w,B)}return w}}function Cn(t){return t%Ce===De?Ke:t%ke===Ve?Zn:t%je===Tn?Dn(t):Ye(t)}const Vn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function kn(t){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},r=Vn.reduce((n,o)=>(n[o]="function",n),e);return ce(t,r),t}function jn(t,e,r){if(r<j)throw new Error("invalid exponent, negatives unsupported");if(r===j)return t.ONE;if(r===k)return e;let n=t.ONE,o=e;for(;r>j;)r&k&&(n=t.mul(n,o)),o=t.sqr(o),r>>=k;return n}function ze(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),o=e.reduce((s,f,c)=>t.is0(f)?s:(n[c]=s,t.mul(s,f)),t.ONE),i=t.inv(o);return e.reduceRight((s,f,c)=>t.is0(f)?s:(n[c]=t.mul(s,n[c]),t.mul(s,f)),i),n}function me(t,e){const r=(t.ORDER-k)/ft,n=t.pow(e,r),o=t.eql(n,t.ONE),i=t.eql(n,t.ZERO),s=t.eql(n,t.neg(t.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function Kn(t,e){e!==void 0&&at(e);const r=e!==void 0?e:t.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}class Yn{ORDER;BITS;BYTES;isLE;ZERO=j;ONE=k;_lengths;_sqrt;_mod;constructor(e,r={}){if(e<=j)throw new Error("invalid field: expected ORDER > 0, got "+e);let n;this.isLE=!1,r!=null&&typeof r=="object"&&(typeof r.BITS=="number"&&(n=r.BITS),typeof r.sqrt=="function"&&(this.sqrt=r.sqrt),typeof r.isLE=="boolean"&&(this.isLE=r.isLE),r.allowedLengths&&(this._lengths=r.allowedLengths?.slice()),typeof r.modFromBytes=="boolean"&&(this._mod=r.modFromBytes));const{nBitLength:o,nByteLength:i}=Kn(e,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=o,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return Y(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return j<=e&&e<this.ORDER}is0(e){return e===j}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&k)===k}neg(e){return Y(-e,this.ORDER)}eql(e,r){return e===r}sqr(e){return Y(e*e,this.ORDER)}add(e,r){return Y(e+r,this.ORDER)}sub(e,r){return Y(e-r,this.ORDER)}mul(e,r){return Y(e*r,this.ORDER)}pow(e,r){return jn(this,e,r)}div(e,r){return Y(e*Ee(r,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,r){return e+r}subN(e,r){return e-r}mulN(e,r){return e*r}inv(e){return Ee(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=Cn(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?Ze(e,this.BYTES):ie(e,this.BYTES)}fromBytes(e,r=!1){N(e);const{_lengths:n,BYTES:o,isLE:i,ORDER:s,_mod:f}=this;if(n){if(!n.includes(e.length)||e.length>o)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+e.length);const u=new Uint8Array(o);u.set(e,i?0:u.length-e.length),e=u}if(e.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+e.length);let c=i?Te(e):Bt(e);if(f&&(c=Y(c,s)),!r&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return ze(this,e)}cmov(e,r,n){return n?r:e}}function Vt(t,e={}){return new Yn(t,e)}function Me(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Xe(t){const e=Me(t);return e+Math.ceil(e/2)}function Ge(t,e,r=!1){N(t);const n=t.length,o=Me(e),i=Xe(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const s=r?Te(t):Bt(t),f=Y(s,e-k)+k;return r?Ze(f,o):ie(f,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yt=BigInt(0),ut=BigInt(1);function $t(t,e){const r=e.negate();return t?r:e}function xe(t,e){const r=ze(t.Fp,e.map(n=>n.Z));return e.map((n,o)=>t.fromAffine(n.toAffine(r[o])))}function Fe(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Kt(t,e){Fe(t,e);const r=Math.ceil(e/t)+1,n=2**(t-1),o=2**t,i=se(t),s=BigInt(t);return{windows:r,windowSize:n,mask:i,maxNumber:o,shiftBy:s}}function Be(t,e,r){const{windowSize:n,mask:o,maxNumber:i,shiftBy:s}=r;let f=Number(t&o),c=t>>s;f>n&&(f-=i,c+=ut);const u=e*n,d=u+Math.abs(f)-1,a=f===0,b=f<0,w=e%2!==0;return{nextN:c,offset:d,isZero:a,isNeg:b,isNegF:w,offsetF:u}}const Yt=new WeakMap,We=new WeakMap;function zt(t){return We.get(t)||1}function ve(t){if(t!==yt)throw new Error("invalid wNAF")}class zn{BASE;ZERO;Fn;bits;constructor(e,r){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=r}_unsafeLadder(e,r,n=this.ZERO){let o=e;for(;r>yt;)r&ut&&(n=n.add(o)),o=o.double(),r>>=ut;return n}precomputeWindow(e,r){const{windows:n,windowSize:o}=Kt(r,this.bits),i=[];let s=e,f=s;for(let c=0;c<n;c++){f=s,i.push(f);for(let u=1;u<o;u++)f=f.add(s),i.push(f);s=f.double()}return i}wNAF(e,r,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let o=this.ZERO,i=this.BASE;const s=Kt(e,this.bits);for(let f=0;f<s.windows;f++){const{nextN:c,offset:u,isZero:d,isNeg:a,isNegF:b,offsetF:w}=Be(n,f,s);n=c,d?i=i.add($t(b,r[w])):o=o.add($t(a,r[u]))}return ve(n),{p:o,f:i}}wNAFUnsafe(e,r,n,o=this.ZERO){const i=Kt(e,this.bits);for(let s=0;s<i.windows&&n!==yt;s++){const{nextN:f,offset:c,isZero:u,isNeg:d}=Be(n,s,i);if(n=f,!u){const a=r[c];o=o.add(d?a.negate():a)}}return ve(n),o}getPrecomputes(e,r,n){let o=Yt.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&(typeof n=="function"&&(o=n(o)),Yt.set(r,o))),o}cached(e,r,n){const o=zt(e);return this.wNAF(o,this.getPrecomputes(o,e,n),r)}unsafe(e,r,n,o){const i=zt(e);return i===1?this._unsafeLadder(e,r,o):this.wNAFUnsafe(i,this.getPrecomputes(i,e,n),r,o)}createCache(e,r){Fe(r,this.bits),We.set(e,r),Yt.delete(e)}hasCache(e){return zt(e)!==1}}function Mn(t,e,r,n){let o=e,i=t.ZERO,s=t.ZERO;for(;r>yt||n>yt;)r&ut&&(i=i.add(o)),n&ut&&(s=s.add(o)),o=o.double(),r>>=ut,n>>=ut;return{p1:i,p2:s}}function Ae(t,e,r){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return kn(e),e}else return Vt(t,{isLE:r})}function Xn(t,e,r={},n){if(n===void 0&&(n=t==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${t} CURVE object`);for(const c of["p","n","h"]){const u=e[c];if(!(typeof u=="bigint"&&u>yt))throw new Error(`CURVE.${c} must be positive bigint`)}const o=Ae(e.p,r.Fp,n),i=Ae(e.n,r.Fn,n),f=["Gx","Gy","a","b"];for(const c of f)if(!o.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:o,Fn:i}}function Pe(t,e){return function(n){const o=t(n);return{secretKey:o,publicKey:e(o)}}}class Qe{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(e,r){if(Ne(e),N(r,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?e.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),_t(o)}update(e){return It(this),this.iHash.update(e),this}digestInto(e){It(this),N(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||=Object.create(Object.getPrototypeOf(this),{});const{oHash:r,iHash:n,finished:o,destroyed:i,blockLen:s,outputLen:f}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=s,e.outputLen=f,e.oHash=r._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Je=(t,e,r)=>new Qe(t,e).update(r).digest();Je.create=(t,e)=>new Qe(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Re=(t,e)=>(t+(t>=0?e:-e)/tn)/e;function Gn(t,e,r){const[[n,o],[i,s]]=e,f=Re(s*t,r),c=Re(-o*t,r);let u=t-f*n-c*i,d=-f*o-c*s;const a=u<J,b=d<J;a&&(u=-u),b&&(d=-d);const w=se(Math.ceil($n(r)/2))+wt;if(u<J||u>=w||d<J||d>=w)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:a,k1:u,k2neg:b,k2:d}}function Wt(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function Mt(t,e){const r={};for(let n of Object.keys(e))r[n]=t[n]===void 0?e[n]:t[n];return Nt(r.lowS,"lowS"),Nt(r.prehash,"prehash"),r.format!==void 0&&Wt(r.format),r}class Fn extends Error{constructor(e=""){super(e)}}const nt={Err:Fn,_tlv:{encode:(t,e)=>{const{Err:r}=nt;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,o=Rt(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const i=n>127?Rt(o.length/2|128):"";return Rt(t)+i+o+e},decode(t,e){const{Err:r}=nt;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const o=e[n++],i=!!(o&128);let s=0;if(!i)s=o;else{const c=o&127;if(!c)throw new r("tlv.decode(long): indefinite length not supported");if(c>4)throw new r("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+c);if(u.length!==c)throw new r("tlv.decode: length bytes not complete");if(u[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const d of u)s=s<<8|d;if(n+=c,s<128)throw new r("tlv.decode(long): not minimal encoding")}const f=e.subarray(n,n+s);if(f.length!==s)throw new r("tlv.decode: wrong value length");return{v:f,l:e.subarray(n+s)}}},_int:{encode(t){const{Err:e}=nt;if(t<J)throw new e("integer: negative integers are not allowed");let r=Rt(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=nt;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Bt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=nt,o=N(t,void 0,"signature"),{v:i,l:s}=n.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:c}=n.decode(2,i),{v:u,l:d}=n.decode(2,c);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(f),s:r.decode(u)}},hexFromSig(t){const{_tlv:e,_int:r}=nt,n=e.encode(2,r.encode(t.r)),o=e.encode(2,r.encode(t.s)),i=n+o;return e.encode(48,i)}},J=BigInt(0),wt=BigInt(1),tn=BigInt(2),Ot=BigInt(3),Wn=BigInt(4);function Pn(t,e={}){const r=Xn("weierstrass",t,e),{Fp:n,Fn:o}=r;let i=r.CURVE;const{h:s,n:f}=i;ce(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=nn(n,o);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function a(U,g,h){const{x:l,y:p}=g.toAffine(),v=n.toBytes(l);if(Nt(h,"isCompressed"),h){d();const R=!n.isOdd(p);return G(en(R),v)}else return G(Uint8Array.of(4),v,n.toBytes(p))}function b(U){N(U,void 0,"Point");const{publicKey:g,publicKeyUncompressed:h}=u,l=U.length,p=U[0],v=U.subarray(1);if(l===g&&(p===2||p===3)){const R=n.fromBytes(v);if(!n.isValid(R))throw new Error("bad point: is not on curve, wrong x");const A=m(R);let x;try{x=n.sqrt(A)}catch(T){const $=T instanceof Error?": "+T.message:"";throw new Error("bad point: is not on curve, sqrt error"+$)}d();const O=n.isOdd(x);return(p&1)===1!==O&&(x=n.neg(x)),{x:R,y:x}}else if(l===h&&p===4){const R=n.BYTES,A=n.fromBytes(v.subarray(0,R)),x=n.fromBytes(v.subarray(R,R*2));if(!E(A,x))throw new Error("bad point: is not on curve");return{x:A,y:x}}else throw new Error(`bad point: got length ${l}, expected compressed=${g} or uncompressed=${h}`)}const w=e.toBytes||a,y=e.fromBytes||b;function m(U){const g=n.sqr(U),h=n.mul(g,U);return n.add(n.add(h,n.mul(U,i.a)),i.b)}function E(U,g){const h=n.sqr(g),l=m(U);return n.eql(h,l)}if(!E(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const B=n.mul(n.pow(i.a,Ot),Wn),L=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(B,L)))throw new Error("bad curve params: a or b");function Z(U,g,h=!1){if(!n.isValid(g)||h&&n.is0(g))throw new Error(`bad point coordinate ${U}`);return g}function C(U){if(!(U instanceof _))throw new Error("Weierstrass Point expected")}function W(U){if(!c||!c.basises)throw new Error("no endo");return Gn(U,c.basises,o.ORDER)}const z=pe((U,g)=>{const{X:h,Y:l,Z:p}=U;if(n.eql(p,n.ONE))return{x:h,y:l};const v=U.is0();g==null&&(g=v?n.ONE:n.inv(p));const R=n.mul(h,g),A=n.mul(l,g),x=n.mul(p,g);if(v)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:R,y:A}}),bt=pe(U=>{if(U.is0()){if(e.allowInfinityPoint&&!n.is0(U.Y))return;throw new Error("bad point: ZERO")}const{x:g,y:h}=U.toAffine();if(!n.isValid(g)||!n.isValid(h))throw new Error("bad point: x or y not field elements");if(!E(g,h))throw new Error("bad point: equation left != right");if(!U.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function st(U,g,h,l,p){return h=new _(n.mul(h.X,U),h.Y,h.Z),g=$t(l,g),h=$t(p,h),g.add(h)}class _{static BASE=new _(i.Gx,i.Gy,n.ONE);static ZERO=new _(n.ZERO,n.ONE,n.ZERO);static Fp=n;static Fn=o;X;Y;Z;constructor(g,h,l){this.X=Z("x",g),this.Y=Z("y",h,!0),this.Z=Z("z",l),Object.freeze(this)}static CURVE(){return i}static fromAffine(g){const{x:h,y:l}=g||{};if(!g||!n.isValid(h)||!n.isValid(l))throw new Error("invalid affine point");if(g instanceof _)throw new Error("projective point not allowed");return n.is0(h)&&n.is0(l)?_.ZERO:new _(h,l,n.ONE)}static fromBytes(g){const h=_.fromAffine(y(N(g,void 0,"point")));return h.assertValidity(),h}static fromHex(g){return _.fromBytes(Ut(g))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(g=8,h=!0){return ct.createCache(this,g),h||this.multiply(Ot),this}assertValidity(){bt(this)}hasEvenY(){const{y:g}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(g)}equals(g){C(g);const{X:h,Y:l,Z:p}=this,{X:v,Y:R,Z:A}=g,x=n.eql(n.mul(h,A),n.mul(v,p)),O=n.eql(n.mul(l,A),n.mul(R,p));return x&&O}negate(){return new _(this.X,n.neg(this.Y),this.Z)}double(){const{a:g,b:h}=i,l=n.mul(h,Ot),{X:p,Y:v,Z:R}=this;let A=n.ZERO,x=n.ZERO,O=n.ZERO,S=n.mul(p,p),T=n.mul(v,v),$=n.mul(R,R),I=n.mul(p,v);return I=n.add(I,I),O=n.mul(p,R),O=n.add(O,O),A=n.mul(g,O),x=n.mul(l,$),x=n.add(A,x),A=n.sub(T,x),x=n.add(T,x),x=n.mul(A,x),A=n.mul(I,A),O=n.mul(l,O),$=n.mul(g,$),I=n.sub(S,$),I=n.mul(g,I),I=n.add(I,O),O=n.add(S,S),S=n.add(O,S),S=n.add(S,$),S=n.mul(S,I),x=n.add(x,S),$=n.mul(v,R),$=n.add($,$),S=n.mul($,I),A=n.sub(A,S),O=n.mul($,T),O=n.add(O,O),O=n.add(O,O),new _(A,x,O)}add(g){C(g);const{X:h,Y:l,Z:p}=this,{X:v,Y:R,Z:A}=g;let x=n.ZERO,O=n.ZERO,S=n.ZERO;const T=i.a,$=n.mul(i.b,Ot);let I=n.mul(h,v),q=n.mul(l,R),D=n.mul(p,A),M=n.add(h,l),H=n.add(v,R);M=n.mul(M,H),H=n.add(I,q),M=n.sub(M,H),H=n.add(h,p);let V=n.add(v,A);return H=n.mul(H,V),V=n.add(I,D),H=n.sub(H,V),V=n.add(l,p),x=n.add(R,A),V=n.mul(V,x),x=n.add(q,D),V=n.sub(V,x),S=n.mul(T,H),x=n.mul($,D),S=n.add(x,S),x=n.sub(q,S),S=n.add(q,S),O=n.mul(x,S),q=n.add(I,I),q=n.add(q,I),D=n.mul(T,D),H=n.mul($,H),q=n.add(q,D),D=n.sub(I,D),D=n.mul(T,D),H=n.add(H,D),I=n.mul(q,H),O=n.add(O,I),I=n.mul(V,H),x=n.mul(M,x),x=n.sub(x,I),I=n.mul(M,q),S=n.mul(V,S),S=n.add(S,I),new _(x,O,S)}subtract(g){return this.add(g.negate())}is0(){return this.equals(_.ZERO)}multiply(g){const{endo:h}=e;if(!o.isValidNot0(g))throw new Error("invalid scalar: out of range");let l,p;const v=R=>ct.cached(this,R,A=>xe(_,A));if(h){const{k1neg:R,k1:A,k2neg:x,k2:O}=W(g),{p:S,f:T}=v(A),{p:$,f:I}=v(O);p=T.add(I),l=st(h.beta,S,$,R,x)}else{const{p:R,f:A}=v(g);l=R,p=A}return xe(_,[l,p])[0]}multiplyUnsafe(g){const{endo:h}=e,l=this;if(!o.isValid(g))throw new Error("invalid scalar: out of range");if(g===J||l.is0())return _.ZERO;if(g===wt)return l;if(ct.hasCache(this))return this.multiply(g);if(h){const{k1neg:p,k1:v,k2neg:R,k2:A}=W(g),{p1:x,p2:O}=Mn(_,l,v,A);return st(h.beta,x,O,p,R)}else return ct.unsafe(l,g)}toAffine(g){return z(this,g)}isTorsionFree(){const{isTorsionFree:g}=e;return s===wt?!0:g?g(_,this):ct.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:g}=e;return s===wt?this:g?g(_,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(g=!0){return Nt(g,"isCompressed"),this.assertValidity(),w(_,this,g)}toHex(g=!0){return Dt(this.toBytes(g))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const vt=o.BITS,ct=new zn(_,e.endo?Math.ceil(vt/2):vt);return _.BASE.precompute(8),_}function en(t){return Uint8Array.of(t?2:3)}function nn(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Qn(t,e={}){const{Fn:r}=t,n=e.randomBytes||Ct,o=Object.assign(nn(t.Fp,r),{seed:Xe(r.ORDER)});function i(w){try{const y=r.fromBytes(w);return r.isValidNot0(y)}catch{return!1}}function s(w,y){const{publicKey:m,publicKeyUncompressed:E}=o;try{const B=w.length;return y===!0&&B!==m||y===!1&&B!==E?!1:!!t.fromBytes(w)}catch{return!1}}function f(w=n(o.seed)){return Ge(N(w,o.seed,"seed"),r.ORDER)}function c(w,y=!0){return t.BASE.multiply(r.fromBytes(w)).toBytes(y)}function u(w){const{secretKey:y,publicKey:m,publicKeyUncompressed:E}=o;if(!re(w)||"_lengths"in r&&r._lengths||y===m)return;const B=N(w,void 0,"key").length;return B===m||B===E}function d(w,y,m=!0){if(u(w)===!0)throw new Error("first arg must be private key");if(u(y)===!1)throw new Error("second arg must be public key");const E=r.fromBytes(w);return t.fromBytes(y).multiply(E).toBytes(m)}const a={isValidSecretKey:i,isValidPublicKey:s,randomSecretKey:f},b=Pe(f,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:b,Point:t,utils:a,lengths:o})}function Jn(t,e,r={}){Ne(e),ce(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),r=Object.assign({},r);const n=r.randomBytes||Ct,o=r.hmac||((h,l)=>Je(e,h,l)),{Fp:i,Fn:s}=t,{ORDER:f,BITS:c}=s,{keygen:u,getPublicKey:d,getSharedSecret:a,utils:b,lengths:w}=Qn(t,r),y={prehash:!0,lowS:typeof r.lowS=="boolean"?r.lowS:!0,format:"compact",extraEntropy:!1},m=f*tn<i.ORDER;function E(h){const l=f>>wt;return h>l}function B(h,l){if(!s.isValidNot0(l))throw new Error(`invalid signature ${h}: out of range 1..Point.Fn.ORDER`);return l}function L(){if(m)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function Z(h,l){Wt(l);const p=w.signature,v=l==="compact"?p:l==="recovered"?p+1:void 0;return N(h,v)}class C{r;s;recovery;constructor(l,p,v){if(this.r=B("r",l),this.s=B("s",p),v!=null){if(L(),![0,1,2,3].includes(v))throw new Error("invalid recovery id");this.recovery=v}Object.freeze(this)}static fromBytes(l,p=y.format){Z(l,p);let v;if(p==="der"){const{r:O,s:S}=nt.toSig(N(l));return new C(O,S)}p==="recovered"&&(v=l[0],p="compact",l=l.subarray(1));const R=w.signature/2,A=l.subarray(0,R),x=l.subarray(R,R*2);return new C(s.fromBytes(A),s.fromBytes(x),v)}static fromHex(l,p){return this.fromBytes(Ut(l),p)}assertRecovery(){const{recovery:l}=this;if(l==null)throw new Error("invalid recovery id: must be present");return l}addRecoveryBit(l){return new C(this.r,this.s,l)}recoverPublicKey(l){const{r:p,s:v}=this,R=this.assertRecovery(),A=R===2||R===3?p+f:p;if(!i.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const x=i.toBytes(A),O=t.fromBytes(G(en((R&1)===0),x)),S=s.inv(A),T=z(N(l,void 0,"msgHash")),$=s.create(-T*S),I=s.create(v*S),q=t.BASE.multiplyUnsafe($).add(O.multiplyUnsafe(I));if(q.is0())throw new Error("invalid recovery: point at infinify");return q.assertValidity(),q}hasHighS(){return E(this.s)}toBytes(l=y.format){if(Wt(l),l==="der")return Ut(nt.hexFromSig(this));const{r:p,s:v}=this,R=s.toBytes(p),A=s.toBytes(v);return l==="recovered"?(L(),G(Uint8Array.of(this.assertRecovery()),R,A)):G(R,A)}toHex(l){return Dt(this.toBytes(l))}}const W=r.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const p=Bt(l),v=l.length*8-c;return v>0?p>>BigInt(v):p},z=r.bits2int_modN||function(l){return s.create(W(l))},bt=se(c);function st(h){return Nn("num < 2^"+c,h,J,bt),s.toBytes(h)}function _(h,l){return N(h,void 0,"message"),l?N(e(h),void 0,"prehashed message"):h}function vt(h,l,p){const{lowS:v,prehash:R,extraEntropy:A}=Mt(p,y);h=_(h,R);const x=z(h),O=s.fromBytes(l);if(!s.isValidNot0(O))throw new Error("invalid private key");const S=[st(O),st(x)];if(A!=null&&A!==!1){const q=A===!0?n(w.secretKey):A;S.push(N(q,void 0,"extraEntropy"))}const T=G(...S),$=x;function I(q){const D=W(q);if(!s.isValidNot0(D))return;const M=s.inv(D),H=t.BASE.multiply(D).toAffine(),V=s.create(H.x);if(V===J)return;const At=s.create(M*s.create($+V*O));if(At===J)return;let ge=(H.x===V?0:2)|Number(H.y&wt),ye=At;return v&&E(At)&&(ye=s.neg(At),ge^=1),new C(V,ye,m?void 0:ge)}return{seed:T,k2sig:I}}function ct(h,l,p={}){const{seed:v,k2sig:R}=vt(h,l,p);return qn(e.outputLen,s.BYTES,o)(v,R).toBytes(p.format)}function U(h,l,p,v={}){const{lowS:R,prehash:A,format:x}=Mt(v,y);if(p=N(p,void 0,"publicKey"),l=_(l,A),!re(h)){const O=h instanceof C?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+O)}Z(h,x);try{const O=C.fromBytes(h,x),S=t.fromBytes(p);if(R&&O.hasHighS())return!1;const{r:T,s:$}=O,I=z(l),q=s.inv($),D=s.create(I*q),M=s.create(T*q),H=t.BASE.multiplyUnsafe(D).add(S.multiplyUnsafe(M));return H.is0()?!1:s.create(H.x)===T}catch{return!1}}function g(h,l,p={}){const{prehash:v}=Mt(p,y);return l=_(l,v),C.fromBytes(h,"recovered").recoverPublicKey(l).toBytes()}return Object.freeze({keygen:u,getPublicKey:d,getSharedSecret:a,utils:b,lengths:w,Point:t,sign:ct,verify:U,recoverPublicKey:g,Signature:C,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},tr={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},er=BigInt(0),Pt=BigInt(2);function nr(t){const e=kt.p,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),f=BigInt(44),c=BigInt(88),u=t*t*t%e,d=u*u*t%e,a=K(d,r,e)*d%e,b=K(a,r,e)*d%e,w=K(b,Pt,e)*u%e,y=K(w,o,e)*w%e,m=K(y,i,e)*y%e,E=K(m,f,e)*m%e,B=K(E,c,e)*E%e,L=K(B,f,e)*m%e,Z=K(L,r,e)*d%e,C=K(Z,s,e)*y%e,W=K(C,n,e)*u%e,z=K(W,Pt,e);if(!qt.eql(qt.sqr(z),t))throw new Error("Cannot find square root");return z}const qt=Vt(kt.p,{sqrt:nr}),lt=Pn(kt,{Fp:qt,endo:tr}),Rr=Jn(lt,Gt),Oe={};function Ht(t,...e){let r=Oe[t];if(r===void 0){const n=Gt(_n(t));r=G(n,n),Oe[t]=r}return Gt(G(r,...e))}const ue=t=>t.toBytes(!0).slice(1),ae=t=>t%Pt===er;function Qt(t){const{Fn:e,BASE:r}=lt,n=e.fromBytes(t),o=r.multiply(n);return{scalar:ae(o.y)?n:e.neg(n),bytes:ue(o)}}function rn(t){const e=qt;if(!e.isValidNot0(t))throw new Error("invalid x: Fail if x â‰¥ p");const r=e.create(t*t),n=e.create(r*t+BigInt(7));let o=e.sqrt(n);ae(o)||(o=e.neg(o));const i=lt.fromAffine({x:t,y:o});return i.assertValidity(),i}const Et=Bt;function on(...t){return lt.Fn.create(Et(Ht("BIP0340/challenge",...t)))}function Se(t){return Qt(t).bytes}function rr(t,e,r=Ct(32)){const{Fn:n}=lt,o=N(t,void 0,"message"),{bytes:i,scalar:s}=Qt(e),f=N(r,32,"auxRand"),c=n.toBytes(s^Et(Ht("BIP0340/aux",f))),u=Ht("BIP0340/nonce",c,i,o),{bytes:d,scalar:a}=Qt(u),b=on(d,i,o),w=new Uint8Array(64);if(w.set(d,0),w.set(n.toBytes(n.create(a+b*s)),32),!sn(w,o,i))throw new Error("sign: Invalid signature produced");return w}function sn(t,e,r){const{Fp:n,Fn:o,BASE:i}=lt,s=N(t,64,"signature"),f=N(e,void 0,"message"),c=N(r,32,"publicKey");try{const u=rn(Et(c)),d=Et(s.subarray(0,32));if(!n.isValidNot0(d))return!1;const a=Et(s.subarray(32,64));if(!o.isValidNot0(a))return!1;const b=on(o.toBytes(d),ue(u),f),w=i.multiplyUnsafe(a).add(u.multiplyUnsafe(o.neg(b))),{x:y,y:m}=w.toAffine();return!(w.is0()||!ae(m)||y!==d)}catch{return!1}}const Or=(()=>{const r=(n=Ct(48))=>Ge(n,kt.n);return{keygen:Pe(r,Se),getPublicKey:Se,sign:rr,verify:sn,Point:lt,utils:{randomSecretKey:r,taggedHash:Ht,lift_x:rn,pointToBytes:ue},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function de(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function or(t){if(!de(t))throw new Error("Uint8Array expected")}function cn(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(r=>typeof r=="string"):e.every(r=>Number.isSafeInteger(r)):!1}function ir(t){if(typeof t!="function")throw new Error("function expected");return!0}function dt(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function le(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Jt(t){if(!Array.isArray(t))throw new Error("array expected")}function Tt(t,e){if(!cn(!0,e))throw new Error(`${t}: array of strings expected`)}function fn(t,e){if(!cn(!1,e))throw new Error(`${t}: array of numbers expected`)}function un(...t){const e=i=>i,r=(i,s)=>f=>i(s(f)),n=t.map(i=>i.encode).reduceRight(r,e),o=t.map(i=>i.decode).reduce(r,e);return{encode:n,decode:o}}function an(t){const e=typeof t=="string"?t.split(""):t,r=e.length;Tt("alphabet",e);const n=new Map(e.map((o,i)=>[o,i]));return{encode:o=>(Jt(o),o.map(i=>{if(!Number.isSafeInteger(i)||i<0||i>=r)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${t}`);return e[i]})),decode:o=>(Jt(o),o.map(i=>{dt("alphabet.decode",i);const s=n.get(i);if(s===void 0)throw new Error(`Unknown letter: "${i}". Allowed: ${t}`);return s}))}}function dn(t=""){return dt("join",t),{encode:e=>(Tt("join.decode",e),e.join(t)),decode:e=>(dt("join.decode",e),e.split(t))}}function sr(t,e="="){return le(t),dt("padding",e),{encode(r){for(Tt("padding.encode",r);r.length*t%8;)r.push(e);return r},decode(r){Tt("padding.decode",r);let n=r.length;if(n*t%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;n>0&&r[n-1]===e;n--)if((n-1)*t%8===0)throw new Error("padding: invalid, string has too much padding");return r.slice(0,n)}}}const ln=(t,e)=>e===0?t:ln(e,t%e),Zt=(t,e)=>t+(e-ln(t,e)),Lt=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function te(t,e,r,n){if(Jt(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(Zt(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Zt(e,r)}`);let o=0,i=0;const s=Lt[e],f=Lt[r]-1,c=[];for(const u of t){if(le(u),u>=s)throw new Error(`convertRadix2: invalid data word=${u} from=${e}`);if(o=o<<e|u,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=r;i-=r)c.push((o>>i-r&f)>>>0);const d=Lt[i];if(d===void 0)throw new Error("invalid carry");o&=d-1}if(o=o<<r-i&f,!n&&i>=e)throw new Error("Excess padding");if(!n&&o>0)throw new Error(`Non-zero padding: ${o}`);return n&&i>0&&c.push(o>>>0),c}function hn(t,e=!1){if(le(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Zt(8,t)>32||Zt(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!de(r))throw new Error("radix2.encode input should be Uint8Array");return te(Array.from(r),8,t,!e)},decode:r=>(fn("radix2.decode",r),Uint8Array.from(te(r,t,8,e)))}}function Le(t){return ir(t),function(...e){try{return t.apply(null,e)}catch{}}}const cr=typeof Uint8Array.from([]).toBase64=="function"&&typeof Uint8Array.fromBase64=="function",fr=(t,e)=>{dt("base64",t);const r=/^[A-Za-z0-9=+/]+$/,n="base64";if(t.length>0&&!r.test(t))throw new Error("invalid base64");return Uint8Array.fromBase64(t,{alphabet:n,lastChunkHandling:"strict"})},Sr=cr?{encode(t){return or(t),t.toBase64()},decode(t){return fr(t)}}:un(hn(6),an("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),sr(6),dn("")),ee=un(an("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),dn("")),Ie=[996825010,642813549,513874426,1027748829,705979059];function pt(t){const e=t>>25;let r=(t&33554431)<<5;for(let n=0;n<Ie.length;n++)(e>>n&1)===1&&(r^=Ie[n]);return r}function _e(t,e,r=1){const n=t.length;let o=1;for(let i=0;i<n;i++){const s=t.charCodeAt(i);if(s<33||s>126)throw new Error(`Invalid prefix (${t})`);o=pt(o)^s>>5}o=pt(o);for(let i=0;i<n;i++)o=pt(o)^t.charCodeAt(i)&31;for(let i of e)o=pt(o)^i;for(let i=0;i<6;i++)o=pt(o);return o^=r,ee.encode(te([o%Lt[30]],30,5,!1))}function ur(t){const e=t==="bech32"?1:734539939,r=hn(5),n=r.decode,o=r.encode,i=Le(n);function s(a,b,w=90){dt("bech32.encode prefix",a),de(b)&&(b=Array.from(b)),fn("bech32.encode",b);const y=a.length;if(y===0)throw new TypeError(`Invalid prefix length ${y}`);const m=y+7+b.length;if(w!==!1&&m>w)throw new TypeError(`Length ${m} exceeds limit ${w}`);const E=a.toLowerCase(),B=_e(E,b,e);return`${E}1${ee.encode(b)}${B}`}function f(a,b=90){dt("bech32.decode input",a);const w=a.length;if(w<8||b!==!1&&w>b)throw new TypeError(`invalid string length: ${w} (${a}). Expected (8..${b})`);const y=a.toLowerCase();if(a!==y&&a!==a.toUpperCase())throw new Error("String must be lowercase or uppercase");const m=y.lastIndexOf("1");if(m===0||m===-1)throw new Error('Letter "1" must be present between prefix and data only');const E=y.slice(0,m),B=y.slice(m+1);if(B.length<6)throw new Error("Data must be at least 6 characters long");const L=ee.decode(B).slice(0,-6),Z=_e(E,L,e);if(!B.endsWith(Z))throw new Error(`Invalid checksum in ${a}: expected "${Z}"`);return{prefix:E,words:L}}const c=Le(f);function u(a){const{prefix:b,words:w}=f(a,!1);return{prefix:b,words:w,bytes:n(w)}}function d(a,b){return s(a,o(b))}return{encode:s,decode:f,encodeFromBytes:d,decodeToBytes:u,decodeUnsafe:c,fromWords:n,fromWordsUnsafe:i,toWords:o}}const Lr=ur("bech32");/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function ar(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Ir(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}function _r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Q(t,e,r=""){const n=ar(t),o=t?.length,i=e!==void 0;if(!n||i&&o!==e){const s=r&&`"${r}" `,f=i?` of length ${e}`:"",c=n?`length=${o}`:`type=${typeof t}`;throw new Error(s+"expected Uint8Array"+f+", got "+c)}return t}function rt(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function xt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}const dr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function lr(t,e){return t.buffer===e.buffer&&t.byteOffset<e.byteOffset+e.byteLength&&e.byteOffset<t.byteOffset+t.byteLength}function wn(t,e){if(lr(t,e)&&t.byteOffset<e.byteOffset)throw new Error("complex overlap of input and output is not supported")}function Ur(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function Nr(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}const hr=(t,e)=>{function r(n,...o){if(Q(n,void 0,"key"),!dr)throw new Error("Non little-endian hardware is not yet supported");if(t.nonceLength!==void 0){const d=o[0];Q(d,t.varSizeNonce?void 0:t.nonceLength,"nonce")}const i=t.tagLength;i&&o[1]!==void 0&&Q(o[1],void 0,"AAD");const s=e(n,...o),f=(d,a)=>{if(a!==void 0){if(d!==2)throw new Error("cipher output not supported");Q(a,void 0,"output")}};let c=!1;return{encrypt(d,a){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Q(d),f(s.encrypt.length,a),s.encrypt(d,a)},decrypt(d,a){if(Q(d),i&&d.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return f(s.decrypt.length,a),s.decrypt(d,a)}}}return Object.assign(r,t),r};function gn(t,e,r=!0){if(e===void 0)return new Uint8Array(t);if(e.length!==t)throw new Error('"output" expected Uint8Array of length '+t+", got: "+e.length);if(r&&!gt(e))throw new Error("invalid output, must be aligned");return e}function gt(t){return t.byteOffset%4===0}function mt(t){return Uint8Array.from(t)}const it=16,wr=283;function gr(t){if(![16,24,32].includes(t.length))throw new Error('"aes key" expected Uint8Array of length 16/24/32, got length='+t.length)}function he(t){return t<<1^wr&-(t>>7)}function ht(t,e){let r=0;for(;e>0;e>>=1)r^=t&-(e&1),t=he(t);return r}const ne=(()=>{const t=new Uint8Array(256);for(let r=0,n=1;r<256;r++,n^=he(n))t[r]=n;const e=new Uint8Array(256);e[0]=99;for(let r=0;r<255;r++){let n=t[255-r];n|=n<<8,e[t[r]]=(n^n>>4^n>>5^n>>6^n>>7^99)&255}return xt(t),e})(),yr=ne.map((t,e)=>ne.indexOf(e)),br=t=>t<<24|t>>>8,Xt=t=>t<<8|t>>>24;function yn(t,e){if(t.length!==256)throw new Error("Wrong sbox length");const r=new Uint32Array(256).map((u,d)=>e(t[d])),n=r.map(Xt),o=n.map(Xt),i=o.map(Xt),s=new Uint32Array(256*256),f=new Uint32Array(256*256),c=new Uint16Array(256*256);for(let u=0;u<256;u++)for(let d=0;d<256;d++){const a=u*256+d;s[a]=r[u]^n[d],f[a]=o[u]^i[d],c[a]=t[u]<<8|t[d]}return{sbox:t,sbox2:c,T0:r,T1:n,T2:o,T3:i,T01:s,T23:f}}const we=yn(ne,t=>ht(t,3)<<24|t<<16|t<<8|ht(t,2)),bn=yn(yr,t=>ht(t,11)<<24|ht(t,13)<<16|ht(t,9)<<8|ht(t,14)),pr=(()=>{const t=new Uint8Array(16);for(let e=0,r=1;e<16;e++,r=he(r))t[e]=r;return t})();function pn(t){Q(t);const e=t.length;gr(t);const{sbox2:r}=we,n=[];gt(t)||n.push(t=mt(t));const o=rt(t),i=o.length,s=c=>F(r,c,c,c,c),f=new Uint32Array(e+28);f.set(o);for(let c=i;c<f.length;c++){let u=f[c-1];c%i===0?u=s(br(u))^pr[c/i-1]:i>6&&c%i===4&&(u=s(u)),f[c]=f[c-i]^u}return xt(...n),f}function Er(t){const e=pn(t),r=e.slice(),n=e.length,{sbox2:o}=we,{T0:i,T1:s,T2:f,T3:c}=bn;for(let u=0;u<n;u+=4)for(let d=0;d<4;d++)r[u+d]=e[n-u-4+d];xt(e);for(let u=4;u<n-4;u++){const d=r[u],a=F(o,d,d,d,d);r[u]=i[a&255]^s[a>>>8&255]^f[a>>>16&255]^c[a>>>24]}return r}function ot(t,e,r,n,o,i){return t[r<<8&65280|n>>>8&255]^e[o>>>8&65280|i>>>24&255]}function F(t,e,r,n,o){return t[e&255|r&65280]|t[n>>>16&255|o>>>16&65280]<<16}function Ue(t,e,r,n,o){const{sbox2:i,T01:s,T23:f}=we;let c=0;e^=t[c++],r^=t[c++],n^=t[c++],o^=t[c++];const u=t.length/4-2;for(let y=0;y<u;y++){const m=t[c++]^ot(s,f,e,r,n,o),E=t[c++]^ot(s,f,r,n,o,e),B=t[c++]^ot(s,f,n,o,e,r),L=t[c++]^ot(s,f,o,e,r,n);e=m,r=E,n=B,o=L}const d=t[c++]^F(i,e,r,n,o),a=t[c++]^F(i,r,n,o,e),b=t[c++]^F(i,n,o,e,r),w=t[c++]^F(i,o,e,r,n);return{s0:d,s1:a,s2:b,s3:w}}function mr(t,e,r,n,o){const{sbox2:i,T01:s,T23:f}=bn;let c=0;e^=t[c++],r^=t[c++],n^=t[c++],o^=t[c++];const u=t.length/4-2;for(let y=0;y<u;y++){const m=t[c++]^ot(s,f,e,o,n,r),E=t[c++]^ot(s,f,r,e,o,n),B=t[c++]^ot(s,f,n,r,e,o),L=t[c++]^ot(s,f,o,n,r,e);e=m,r=E,n=B,o=L}const d=t[c++]^F(i,e,o,n,r),a=t[c++]^F(i,r,e,o,n),b=t[c++]^F(i,n,r,e,o),w=t[c++]^F(i,o,n,r,e);return{s0:d,s1:a,s2:b,s3:w}}function xr(t){if(Q(t),t.length%it!==0)throw new Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size "+it)}function Br(t,e,r){Q(t);let n=t.length;const o=n%it;if(!e&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");gt(t)||(t=mt(t));const i=rt(t);if(e){let f=it-o;f||(f=it),n=n+f}r=gn(n,r),wn(t,r);const s=rt(r);return{b:i,o:s,out:r}}function vr(t,e){if(!e)return t;const r=t.length;if(!r)throw new Error("aes/pcks5: empty ciphertext not allowed");const n=t[r-1];if(n<=0||n>16)throw new Error("aes/pcks5: wrong padding");const o=t.subarray(0,-n);for(let i=0;i<n;i++)if(t[r-i-1]!==n)throw new Error("aes/pcks5: wrong padding");return o}function Ar(t){const e=new Uint8Array(16),r=rt(e);e.set(t);const n=it-t.length;for(let o=it-n;o<it;o++)e[o]=n;return r}const $r=hr({blockSize:16,nonceLength:16},function(e,r,n={}){const o=!n.disablePadding;return{encrypt(i,s){const f=pn(e),{b:c,o:u,out:d}=Br(i,o,s);let a=r;const b=[f];gt(a)||b.push(a=mt(a));const w=rt(a);let y=w[0],m=w[1],E=w[2],B=w[3],L=0;for(;L+4<=c.length;)y^=c[L+0],m^=c[L+1],E^=c[L+2],B^=c[L+3],{s0:y,s1:m,s2:E,s3:B}=Ue(f,y,m,E,B),u[L++]=y,u[L++]=m,u[L++]=E,u[L++]=B;if(o){const Z=Ar(i.subarray(L*4));y^=Z[0],m^=Z[1],E^=Z[2],B^=Z[3],{s0:y,s1:m,s2:E,s3:B}=Ue(f,y,m,E,B),u[L++]=y,u[L++]=m,u[L++]=E,u[L++]=B}return xt(...b),d},decrypt(i,s){xr(i);const f=Er(e);let c=r;const u=[f];gt(c)||u.push(c=mt(c));const d=rt(c);s=gn(i.length,s),gt(i)||u.push(i=mt(i)),wn(i,s);const a=rt(i),b=rt(s);let w=d[0],y=d[1],m=d[2],E=d[3];for(let B=0;B+4<=a.length;){const L=w,Z=y,C=m,W=E;w=a[B+0],y=a[B+1],m=a[B+2],E=a[B+3];const{s0:z,s1:bt,s2:st,s3:_}=mr(f,w,y,m,E);b[B++]=z^L,b[B++]=bt^Z,b[B++]=st^C,b[B++]=_^W}return xt(...u),vr(s,o)}}});export{_r as a,Ir as b,Ur as c,Q as d,mt as e,xt as f,Ne as g,Je as h,at as i,N as j,_t as k,Dt as l,Ut as m,Gt as n,Lr as o,G as p,Rr as q,Ct as r,Or as s,$r as t,rt as u,Sr as v,Nr as w};
